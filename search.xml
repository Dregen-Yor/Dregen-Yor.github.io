<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Toyota Programming Contest 2024#1гиAtCoder Beginner Contest 337题解</title>
    <url>/2024/01/22/Toyota%20Programming%20Contest%202024#1%D0%B3%D0%B8AtCoder%20Beginner%20Contest%20337%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>AtCoder Beginner Contest 337题解</p>
<span id="more"></span>
<h1 id="a">A</h1>
<p>比大小，这个直接上代码了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        x+=a,y+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Takahashi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Aoki&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b">B</h1>
<p>判断字符串是否为 A，B，C 三个字母有序排列的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="type">char</span> s[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">bool</span> fa=<span class="number">0</span>,fb=<span class="number">0</span>,fc=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            fa=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(fb||fc)&#123;</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            fb=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(fc)&#123;</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            fc=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c">C</h1>
<p>给定数组 <span class="math inline">\(A\)</span>，如果 <span class="math inline">\(A_i = -1\)</span> ，则为链表头部，否则 <span class="math inline">\(i\)</span> 的前一位为 <span class="math inline">\(A_i\)</span>，找到头部，按链表的方式遍历即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,n,m,a[<span class="number">300010</span>],head,bh[<span class="number">300010</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            head=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            bh[a[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,head);</span><br><span class="line">        head=bh[head];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="d">D</h1>
<p>我们分别做每一行和每一列的前缀和，统计 <code>x</code> 和 <code>.</code> 的数量。</p>
<p>当 <code>x</code> 为 <span class="math inline">\(0\)</span> 时统计答案即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,h,w,k,sum[<span class="number">200010</span>],d[<span class="number">200010</span>];</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; s[<span class="number">200010</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;h,&amp;w,&amp;k);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">        s[i].<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;</span><br><span class="line">            s[i].<span class="built_in">push_back</span>(str[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;</span><br><span class="line">            sum[j]=sum[j<span class="number">-1</span>]+(s[i][j]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            d[j]=d[j<span class="number">-1</span>]+(s[i][j]==<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=k;j&lt;=w;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j]-d[j-k]&gt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,sum[j]-sum[j-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=h;j++)&#123;</span><br><span class="line">            sum[j]=sum[j<span class="number">-1</span>]+(s[j][i]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            d[j]=d[j<span class="number">-1</span>]+(s[j][i]==<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=k;j&lt;=h;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j]-d[j-k]&gt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,sum[j]-sum[j-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e9</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="e">E</h1>
<p>考虑把每个饮料的编号进行二进制拆分，若某个饮料第 <span class="math inline">\(i\)</span> 位上是 <span class="math inline">\(1\)</span>，则让第 <span class="math inline">\(i\)</span> 位朋友品尝这杯饮料。最后把朋友闹肚子的反馈看成一个二进制串，转化成整数即可。</p>
<p>注意，若 <span class="math inline">\(n\)</span> 可以表示成 <span class="math inline">\(2^k\)</span> 的形式，则最高一位可以省去，即少叫一位朋友，若最后的反馈结果为 <span class="math inline">\(0\)</span> ，则为第 <span class="math inline">\(n\)</span> 位朋友。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;fri[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> id=x;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            fri[len].<span class="built_in">push_back</span>(id);</span><br><span class="line">        &#125;</span><br><span class="line">        ++len;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp=n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,fri[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;fri[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,fri[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            id+=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(id==<span class="number">0</span>)&#123;</span><br><span class="line">        id=n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,id);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="f">F</h1>
<p>对于这题，我们只需要知道是那几种球占了盒子的空位就能得知答案。</p>
<p>我们先用一个桶来存储所有种类的球的数量，然后暴力模拟第一遍，知道所有空盒子装的是哪一种球即可。</p>
<p>我们考虑用双指针来记录盒子装满时是找到了第几个球，每次 <span class="math inline">\(r+1\)</span> 时，左指针向左移动一次，若此时有一个盒子空了出来，就令右指针向右移动，知道找到了下一个球装上了空出的箱子或者走到尽头为止。</p>
<p>我们再用一个桶 <span class="math inline">\(cnt_i\)</span> 记录每种球占了几个箱子，统计答案时，第 <span class="math inline">\(i\)</span> 种球装进箱子的数量为 <span class="math inline">\(\min(cnt_i\times k,sum_i)\)</span>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,n,m,k,a[<span class="number">200010</span>],sum[<span class="number">200010</span>],cnt[<span class="number">200010</span>],now[<span class="number">200010</span>],scnt,ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sum[a[i]]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now[a[i]]%k==<span class="number">0</span>)&#123;</span><br><span class="line">            scnt++;</span><br><span class="line">            cnt[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        now[a[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(scnt==m)&#123;</span><br><span class="line">            r=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">min</span>(cnt[i]*k,sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> X=<span class="number">1</span>;X&lt;n;X++)&#123;</span><br><span class="line">        now[a[l]]--;</span><br><span class="line">        <span class="keyword">if</span>(now[a[l]]%k==<span class="number">0</span>)&#123;</span><br><span class="line">            ans-=<span class="built_in">min</span>(cnt[a[l]]*k,sum[a[l]]);</span><br><span class="line">            cnt[a[l]]--;</span><br><span class="line">            scnt--;</span><br><span class="line">            ans+=<span class="built_in">min</span>(cnt[a[l]]*k,sum[a[l]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(scnt!=m&amp;&amp;(r!=l||f))&#123;</span><br><span class="line">            r++;</span><br><span class="line">            r=(r<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(now[a[r]]%k==<span class="number">0</span>)&#123;</span><br><span class="line">                ans-=<span class="built_in">min</span>(cnt[a[r]]*k,sum[a[r]]);</span><br><span class="line">                cnt[a[r]]++;</span><br><span class="line">                ans+=<span class="built_in">min</span>(cnt[a[r]]*k,sum[a[r]]);</span><br><span class="line">                scnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            now[a[r]]++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="g">G</h1>
<p>这题采用 树上启发式合并+树状数组+树形dp 的方式。</p>
<p>首先在启发式合并的过程中记录出每个节点子树内有多少个节点编号是小于当前节点的。</p>
<p>之后可以得出子树外有多少个节点编号小于当前节点，这样以当前节点为 <span class="math inline">\(w\)</span>，以子树外节点为 <span class="math inline">\(v\)</span> 的答案就统计出来了，我们称这类答案为第一类答案。</p>
<p>设当前节点的父亲节点为 <span class="math inline">\(fa_i\)</span>，我们在子树内查找有多少个点的编号小于父节点的编号，这样以 <span class="math inline">\(fa_i\)</span> 为 <span class="math inline">\(w\)</span>，以子树内的点为 <span class="math inline">\(v\)</span> 的答案就统计出来了，我们称这类答案为全局答案。</p>
<p>我们不难发现，第一类答案是可以传递给子树内节点的，全局答案可以传递给子树外的其他节点。第一类答案的传递比较容易，只需要在遍历时传递即可。</p>
<p>对于全局答案，我们不妨让所有的节点都加上这个全局答案，同时对子树内的所有点减去这个全局答案，减去的值可以和第一类答案一起传递给子树内节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//#define P pair&lt;int,int&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>,n,m,tr[N],dfn[N],id[N],cnt,son[N],siz[N],dp[N],ans[N],tmp[N],All;</span><br><span class="line"><span class="type">int</span> A[N],B[N],d[N],G[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;(-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        tr[i]+=data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        res+=tr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    dfn[x]=++cnt;</span><br><span class="line">    id[cnt]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d[x];i&lt;d[x+<span class="number">1</span>];i++)&#123;</span><br><span class="line">        <span class="type">int</span> to=G[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        siz[x]+=siz[to];</span><br><span class="line">        <span class="keyword">if</span>(siz[to]&gt;siz[son[x]])&#123;</span><br><span class="line">            son[x]=to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trcom</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">bool</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d[x];i&lt;d[x+<span class="number">1</span>];i++)&#123;</span><br><span class="line">        <span class="type">int</span> to=G[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa||to==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">trcom</span>(to,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x])&#123;</span><br><span class="line">        <span class="built_in">trcom</span>(son[x],x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d[x];i&lt;d[x+<span class="number">1</span>];i++)&#123;</span><br><span class="line">        <span class="type">int</span> to=G[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa||to==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=dfn[to];j&lt;dfn[to]+siz[to];j++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(id[j],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(x,<span class="number">1</span>);</span><br><span class="line">    tmp[x]=<span class="built_in">query</span>(x<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(fa!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> val=<span class="built_in">query</span>(fa<span class="number">-1</span>);</span><br><span class="line">        dp[x]-=val;</span><br><span class="line">        All+=val;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x]+=x<span class="number">-1</span>-tmp[x];</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=dfn[x];i&lt;dfn[x]+siz[x];i++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(id[i],<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    ans[x]=dp[x]+All;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d[x];i&lt;d[x+<span class="number">1</span>];i++)&#123;</span><br><span class="line">        <span class="type">int</span> to=G[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dp[to]+=dp[x];</span><br><span class="line">        <span class="built_in">dfs</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildG</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        d[i+<span class="number">1</span>]+=d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        G[--d[A[i]]]=B[i];</span><br><span class="line">        G[--d[B[i]]]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;A[i],&amp;B[i]);</span><br><span class="line">        d[A[i]]++;</span><br><span class="line">        d[B[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buildG</span>();</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">trcom</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub学生包申请流程</title>
    <url>/2023/12/21/GitHub%E5%AD%A6%E7%94%9F%E5%8C%85%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>GitHub 学生包的申请流程。</p>
<span id="more"></span>
<h1 id="github学生包申请教程">GitHub学生包申请教程</h1>
<h2 id="账号绑定">账号绑定</h2>
<p>首先找到账号的设置页面。</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/yrvK2qoaHWR5VSP.jpg" alt="" /><figcaption>1.jpeg</figcaption>
</figure>
<p>在此处添加自己的<strong>学生邮箱</strong>，注意一定要是<strong>学生邮箱</strong>。</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/neuKiNdHv4ExB1J.png" alt="" /><figcaption>2.png</figcaption>
</figure>
<p>然后进入钱包页面，完善自己的钱包信息并保存。</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/AZyiElXuhs96VLY.png" alt="" /><figcaption>3.png</figcaption>
</figure>
<p>之后打开这个页面</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/atUEfer6vkVZWqd.png" alt="" /><figcaption>4.png</figcaption>
</figure>
<p>并往下滑找到</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/EivDwezdJXA8oN1.png" alt="" /><figcaption>5.png</figcaption>
</figure>
<p>点击绿色的 <code>Enable two-factor authentication</code> 按钮。</p>
<p>在手机应用商店下载 <code>Authenticator</code>。</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/fuiNl8znwLSQy4W.jpg" alt="" /><figcaption>6.jpg</figcaption>
</figure>
<p>扫描出现的二维码，完成认证即可。</p>
<p>这时候我们回到 GitHub 首页，就会发现出现一个 Join GitHub Global Campus 的页面。</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/MoclTx3YpEtazsm.jpg" alt="" /><figcaption>7.jpg</figcaption>
</figure>
<h2 id="获取学信网认证资料">获取学信网认证资料</h2>
<p>登录学信网账号，在个人资料左侧找到<strong>在线验证报告</strong>。</p>
<figure>
<img src="https://s2.loli.net/2023/12/21/zpW5Zg4M1PQ9jvU.png" alt="" /><figcaption>8.png</figcaption>
</figure>
<figure>
<img src="https://s2.loli.net/2023/12/21/jKs3S5u2hc4OTYJ.png" alt="" /><figcaption>9.png</figcaption>
</figure>
<p>我们将申请的在线验证报告截图保存，在下一步申请时会用到。</p>
<h2 id="申请学生认证">申请学生认证</h2>
<p>点击首页的 Join GitHub Global Campus，进入学生认证页面。</p>
<p>滑倒最下面，此时邮箱和学校名称已经为你自动补全。</p>
<p>最下面的 "How do you plan to use GitHub?" 可以填 Study。</p>
<p>点击 Continue，然后上传刚才保存的学籍验证报告图片，等待审核即可。</p>
<p>大约 $3 4 $ 天后会有邮件通知。</p>
<h2 id="附加">附加</h2>
<p><del>都看到这里了，把 JetBrain 的也申请了再走吧。</del></p>
<p>打开连接：<a href="https://www.jetbrains.com/shop/eform/students">JetBrains 学习产品</a>。</p>
<p>由于国内学生邮箱管理比较混乱，我们不能通过大学电子邮件地址和 GitHub 进行申请。</p>
<p>选择官方文件选项，按要求填写信息，上传刚才的学信网截图和学信网报告在线验证码即可。</p>
<p>这个申请速度比较缓慢，等待即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/2023/10/27/Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="常见指令">常见指令</h2>
<h3 id="关机">关机</h3>
<p>关机流程一般为 <code>sync-&gt;shutdown-&gt;reboot-&gt;halt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure>
<p>最后总结一些，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。chu</p>
<h3 id="处理目录">处理目录</h3>
<ul>
<li><code>ls</code> ：列出目录及文件名。</li>
<li><code>cd</code> ：切换目录。</li>
<li><code>pwd</code> ：显示目前的目录</li>
<li><code>mkdir</code> ：创建一个新的目录。</li>
<li><code>rmdir</code> ：删除一个空的目录。</li>
<li><code>cp</code> ：复制文件或目录。</li>
<li><code>rm</code> 删除文件或目录。</li>
<li><code>mv</code> ：移动文件与目录，或修改文件与目录的名称。</li>
</ul>
<p>可以使用 <code>man [命令]</code> 来查看各各命令的使用文档，如： ``</p>
<h2 id="系统目录结构">系统目录结构</h2>
<p>登录系统后，在终端内输入如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>
<p>会看到若干目录，一下是对这些目录的解释：</p>
<ul>
<li><p>/bin</p>
<p>bin是 Binaries （二进制文件）的缩写，这个目录存放着最经常使用的命令。</p></li>
<li><p>/boot</p>
<p>这里存放的是启动 Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li>
<li><p>/dev</p>
<p>dev 是 Device（设备）的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li>
<li><p>/etc</p>
<p>etc 是 Etcetera （等等）的缩写，这个目录用来存放所有的系统管理苏哦需要的配置文件和子目录。</p></li>
<li><p>/home</p>
<p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li>
<li><p>/lib</p>
<p>lib 是 Library（库）的缩写，这个目录里存放着系统最基本的动态链接共享库，其作用类似于 Windows 里的 DLL 文件，几乎所有的英语程序都需要用到这些共享库。</p></li>
<li><p>/lost+found</p>
<p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li>
<li><p>/media</p>
<p>Linux 会自动识别一些设备，如 U 盘，光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li>
<li><p>/mnt</p>
<p>系统提供该目录是为了让用户临时挂载别的系统文件的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p></li>
<li><p>/opt</p>
<p>opt 是 optional（可选）的缩写，这里是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</p></li>
<li><p>/proc</p>
<p>proc 是 Processes（进程）的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p>/root</p>
<p>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li>
<li><p>/sbin</p>
<p>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li>
<li><p>/selinux</p>
<p>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 Windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</p></li>
<li><p>/srv</p>
<p>该目录存放一些服务启动后需要提取的数据。</p></li>
<li><p>/sys</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。</p>
<p>sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统，针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li>
<li><p>/tmp</p>
<p>tmp 是 temporary（临时）的缩写，这个目录是用来存放一些临时文件的。</p></li>
<li><p>/usr</p>
<p>usr 是 unix shared resources（共享资源）的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li>
<li><p>/usr/bin</p>
<p>系统用户使用的应用程序。</p></li>
<li><p>/usr/sbin</p>
<p>超级用户使用的比较高级的管理程序和系统守护程序。</p></li>
<li><p>/usr/src</p>
<p>内核源代码默认的放置目录。</p></li>
<li><p>/var</p>
<p>var 是 variable（变量）的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下，包括各种目录日志文件。</p></li>
<li><p>/run</p>
<p>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删除或者清除。如果你的电脑上有 /var/run 目录，应该让它指向 run。</p></li>
</ul>
<p>其中 <strong>/etc</strong> 中的某个文件被更改可能导致<strong>系统不能启动</strong>。<strong>/bin，/usr/bin</strong> 是给系统用户使用的指令（除 <strong>root</strong> 以外的用户），而 <strong>/sbin，/usr/sbin</strong> 则是给 <strong>root</strong> 用户使用的指令。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2023/10/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2023/10/19/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>网络流学习记录</title>
    <url>/2023/10/16/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="网络流">网络流</h1>
<h3 id="二分图">二分图</h3>
<h4 id="特殊的二分图匹配">特殊的二分图匹配</h4>
<h5 id="完备匹配">完备匹配</h5>
<p>对于一张二分图 <span class="math inline">\(((A,B),E)\)</span>，设其最大匹配为 <span class="math inline">\(E^\prime\)</span>，若 <span class="math inline">\(|A|=|B|=|E^\prime|\)</span>，则称这张二分图具有<strong>完备匹配</strong>。</p>
<h5 id="多重匹配">多重匹配</h5>
<p>对于一张二分图 <span class="math inline">\(((A,B),E)\)</span>，从 <span class="math inline">\(E\)</span> 中选出尽量多的边，使 <span class="math inline">\(x \in A\)</span> 最多与 <span class="math inline">\(l_x\)</span> 条选出的边相连，<span class="math inline">\(y \in B\)</span> 最多与 <span class="math inline">\(r_y\)</span> 条选出的边相连，则称选出的边为二分图的<strong>多重匹配</strong>。</p>
<h5 id="最优匹配">最优匹配</h5>
<p>对于一张二分图，边有边权，所有<strong>最大匹配</strong>中边权总和最大的，被称为<strong>最优匹配</strong>。</p>
<h4 id="图的点覆盖">图的点覆盖</h4>
<p>对于一张无向图 <span class="math inline">\((V,E)\)</span>，若存在一个点集 <span class="math inline">\(V^\prime\)</span>，满足 <span class="math inline">\(V^\prime \subseteq V\)</span>，且对于任意 <span class="math inline">\(e \in E\)</span>，<span class="math inline">\(e\)</span> 至少有一个端点属于 <span class="math inline">\(V^\prime\)</span>，则称 <span class="math inline">\(V^\prime\)</span> 为这张无向图的一组<strong>点覆盖</strong>。</p>
<h5 id="二分图最小点覆盖">二分图最小点覆盖</h5>
<p>在二分图中，包含点数最少的一组点覆盖被称为二分图的最小点覆盖。</p>
<h5 id="定理">定理</h5>
<p>在二分图中，最小点覆盖包含的点数，等于最大匹配包含的边数。</p>
<h5 id="二分图最小点覆盖的一个要素二要素">二分图最小点覆盖的一个要素（二要素）</h5>
<p>每条边有两个端点，二者中至少选择一个。</p>
<h4 id="二分图最大独立集">二分图最大独立集</h4>
<h5 id="图的独立集">图的独立集</h5>
<p>对于一张无向图 <span class="math inline">\((V,E)\)</span>,若存在一个点集 <span class="math inline">\(V^\prime\)</span>，满足 <span class="math inline">\(V^\prime \subseteq V\)</span>，且对于任意 <span class="math inline">\(p,q \in V^\prime\)</span>，<span class="math inline">\((p,q) \notin E\)</span>，则称 <span class="math inline">\(V^\prime\)</span> 为这张无向图的一组<strong>独立集</strong>，包含点数最多的独立集称为图的<strong>最大独立集</strong>。</p>
<h5 id="图的团">图的团</h5>
<p>对于一张无向图 <span class="math inline">\((V,E)\)</span>,若存在一个点集 <span class="math inline">\(V^\prime\)</span>，满足 <span class="math inline">\(V^\prime \subseteq V\)</span>，且对于任意 <span class="math inline">\(p,q \in V^\prime\)</span>，<span class="math inline">\((p,q) \in E\)</span>，则称 <span class="math inline">\(V^\prime\)</span> 为这张无向图的一组<strong>团</strong>，包含点数最多的独立团的<strong>最大团</strong>。</p>
<h5 id="定理-1">定理</h5>
<p>对于无向图 <span class="math inline">\(G\)</span> 的最大团，等于补图 <span class="math inline">\(G^\prime\)</span> 的最大独立集。</p>
<p>对于一般无向图，最大团，最大独立集是 NPC 问题。</p>
<h5 id="二分图最大独立集-1">二分图最大独立集</h5>
<p>在二分图中，包含点数最多的一组独立集被称为二分图的最大独立集。</p>
<h5 id="定理-2">定理</h5>
<p>对于一张 <span class="math inline">\(n\)</span> 个点的二分图，最大独立集大小，等于 <span class="math inline">\(n-\)</span> 最小点覆盖点数，等于 <span class="math inline">\(n-\)</span>最大匹配边数。</p>
<h4 id="有向无环图的最小路径点覆盖">有向无环图的最小路径点覆盖</h4>
<p>给定一张<strong>有向无环图</strong>，用尽量少的不相交的简单路径覆盖所有点（也就是每个点恰好被覆盖一次），这样的路径集合被称为<strong>最小路径点覆盖</strong>。</p>
<h5 id="拆点二分图">拆点二分图</h5>
<p>把每个点拆成编号为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(x+n\)</span> 的两个点。</p>
<p>建立一张新的二分图，<span class="math inline">\(1 \sim n\)</span> 是左部点，<span class="math inline">\(n+1 \sim 2n\)</span> 是右部点。</p>
<p>对于原图的每条有向边 <span class="math inline">\((x,y)\)</span>，在二分图的左部点 <span class="math inline">\(x\)</span> 和右部点 <span class="math inline">\(y+n\)</span> 之间连边。</p>
<p>最终得到的二分图即为原图的<strong>拆点二分图</strong>。</p>
<h5 id="定理-3">定理</h5>
<p>有向无环图的最小路径点覆盖包含的路径条数，等于 <span class="math inline">\(n-\)</span> 拆点二分图的最大匹配边数。</p>
<h3 id="最小割">最小割</h3>
<p>给定一个网格 <span class="math inline">\(G=(V,E)\)</span>，源点为 <span class="math inline">\(S\)</span>，汇点为 <span class="math inline">\(T\)</span>。</p>
<p>若一个边集被删去后，源点 <span class="math inline">\(S\)</span> 和汇点 <span class="math inline">\(T\)</span> 不再连通，则称该边集为网络的<strong>割</strong>。</p>
<p>边的容量之和最小的割称为网络的<strong>最小割</strong>。</p>
<h5 id="最大流最小割定理">最大流最小割定理</h5>
<p>最大流等于最小割。</p>
<h5 id="点边转化">点边转化</h5>
<p>把原来无向图中的每个点 <span class="math inline">\(x\)</span>，拆成入点 <span class="math inline">\(x\)</span> 和出点 <span class="math inline">\(x^\prime\)</span>，则在无向图中删去一个点，等价于在网络中断开 <span class="math inline">\((x,x^\prime)\)</span>。</p>
<p>对于任意 <span class="math inline">\(x \neq S\)</span> 且 <span class="math inline">\(x \neq T\)</span> 的点 <span class="math inline">\(x\)</span> 连有向边 <span class="math inline">\((x,x^\prime)\)</span>，容量为 <span class="math inline">\(1\)</span>。</p>
<p>对于原无向图的每条边 <span class="math inline">\((x,y)\)</span>，连有向边 <span class="math inline">\((x^\prime,y)\)</span> 和 <span class="math inline">\((y^\prime,x)\)</span>，容量为 <span class="math inline">\(+\infty\)</span>，即防止割断。</p>
<h5 id="集合划分模型">集合划分模型</h5>
<p>有 <span class="math inline">\(n\)</span> 个物品和两个集合 <span class="math inline">\(S,T\)</span>。</p>
<p>如果将一个物品放入 <span class="math inline">\(S\)</span> 集合会花费 <span class="math inline">\(a_i\)</span>，放入 <span class="math inline">\(T\)</span> 集合会花费 <span class="math inline">\(b_i\)</span>。</p>
<p>还有若干个形如 <span class="math inline">\(u,v,w\)</span> 限制条件，表示如果 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 同时不在一个集合会花费 <span class="math inline">\(w\)</span>。</p>
<p>每个物品必须且只能属于一个集合，求最小的代价。</p>
<p>我们对于每个集合设置源点 <span class="math inline">\(S\)</span> 和汇点 <span class="math inline">\(T\)</span>，第 <span class="math inline">\(i\)</span> 个点由 <span class="math inline">\(S\)</span> 连一条容量为 <span class="math inline">\(b_i\)</span> 的边、向 <span class="math inline">\(T\)</span> 连一条容量为 <span class="math inline">\(a_i\)</span> 的边。</p>
<p>对于限制条件 <span class="math inline">\(u,v,w\)</span>，我们在 <span class="math inline">\(u,v\)</span> 之间连容量为 <span class="math inline">\(w\)</span> 的双向边。</p>
<p>注意到当 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 不相连时，<span class="math inline">\(S\)</span> 能到达 <span class="math inline">\(i\)</span> 代表物品 <span class="math inline">\(i\)</span> 放入 <span class="math inline">\(S\)</span>，<span class="math inline">\(i\)</span> 能到达 <span class="math inline">\(T\)</span> 代表物品 <span class="math inline">\(i\)</span> 放入 <span class="math inline">\(T\)</span>。</p>
<p>当割开 <span class="math inline">\(S \to i\)</span> 的边，意味着 <span class="math inline">\(i\)</span> 放入 <span class="math inline">\(T\)</span>；当割开 <span class="math inline">\(i \to T\)</span> 的边，意味着 <span class="math inline">\(i\)</span> 放入 <span class="math inline">\(S\)</span>；</p>
<p>当割开 <span class="math inline">\(u,v\)</span> 之间的边，意味着 <span class="math inline">\(u,v\)</span> 不放入同一个集合。</p>
<p>因此最小割就是最小花费。</p>
<h5 id="最小割的可行边与必须边">最小割的可行边与必须边</h5>
<p>首先求最大流，那么最小割的可行边与必须边都必须是<strong>满流</strong>。</p>
<ul>
<li>可行边 <span class="math inline">\((x,y)\)</span>：在残量网络中不存在 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的路径。</li>
<li>必须边 <span class="math inline">\((x,y)\)</span>：在残量网络中 <span class="math inline">\(S\)</span> 能到 <span class="math inline">\(x\)</span> 且 <span class="math inline">\(y\)</span> 能到 <span class="math inline">\(T\)</span>。</li>
</ul>
<p>用 Tarjan 跑强连通分量，判断 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 是否在同一强连通分量中，同时判断 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 与 <span class="math inline">\(T\)</span> 是否在同一强连通分量中即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
</search>
